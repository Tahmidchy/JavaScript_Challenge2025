/*
TODO: Question-1: ইভেন্ট লুপ কিভাবে কাজ করে , বিস্তারিত ব্যাখ্যা করো JavaScript এ একটি উদাহরণ সহ।
*/

// Answer: Bangla Explanation of Event Loop in JavaScript with Example

/*
ইভেন্ট লুপ হল JavaScript এর একটি গুরুত্বপূর্ণ অংশ যা অ্যাসিঙ্ক্রোনাস অপারেশনগুলি পরিচালনা করে। JavaScript একটি সিঙ্গল-থ্রেডেড ভাষা, যার মানে এটি এক সময়ে একটি কাজই করতে পারে। তবে, ইভেন্ট লুপের মাধ্যমে এটি অ্যাসিঙ্ক্রোনাস কাজগুলি পরিচালনা করতে সক্ষম হয়, যেমন টাইমআউট, ইভেন্ট হ্যান্ডলার, এবং প্রমিস।  */
// উদাহরণস্বরূপ, নিচের কোডটি দেখুন:
console.log('Start');

setTimeout(() => {
    console.log('Timeout 1');
}, 5000);
setTimeout(() => {
    console.log('Timeout 2');
}, 500);
console.log('End');

// এই উদাহরণে, আমরা দেখতে পাচ্ছি যে 'Start' এবং 'End' প্রথমে কনসোলে প্রিন্ট হবে কারণ তারা সিঙ্ক্রোনাস কোড। তারপর, 'Timeout 2' প্রিন্ট হবে কারণ এটি 500 মিলিসেকেন্ড পরে সেট করা হয়েছে, যা 'Timeout 1' এর চেয়ে কম সময়। অবশেষে, 'Timeout 1' প্রিন্ট হবে কারণ এটি 5000 মিলিসেকেন্ড পরে সেট করা হয়েছে। এই উদাহরণটি ইভেন্ট লুপের কাজ করার পদ্ধতি প্রদর্শন করে যেখানে অ্যাসিঙ্ক্রোনাস কলগুলি তাদের নির্ধারিত সময় অনুযায়ী কার্যকর হয়।

/*
/*
TODO: Question-2: কল স্ট্যাক আর কল ব্যাক queue এর মধ্যে ডিফারেন্স কি ?
*/

// Answer: Difference between Call Stack and Callback Queue

/*
কল স্ট্যাক হল একটি ডেটা স্ট্রাকচার যা ফাংশন কলগুলিকে ট্র্যাক করে। যখন একটি ফাংশন কল করা হয়, এটি কল স্ট্যাকে যোগ করা হয় এবং যখন ফাংশনটি সম্পন্ন হয়, এটি কল স্ট্যাক থেকে সরানো হয়। এটি সিঙ্ক্রোনাস কোডের জন্য ব্যবহৃত হয়। */

/*
অন্যদিকে, কলব্যাক কিউ হল একটি লাইন যা অ্যাসিঙ্ক্রোনাস ফাংশন কলগুলিকে ধরে রাখে যতক্ষণ না তারা কল স্ট্যাকে যোগ করার জন্য প্রস্তুত হয়। যখন কল স্ট্যাক খালি থাকে, ইভেন্ট লুপ কলব্যাক কিউ থেকে ফাংশনগুলি কল স্ট্যাকে নিয়ে আসে এবং সেগুলি কার্যকর করে। এটি অ্যাসিঙ্ক্রোনাস কোডের জন্য ব্যবহৃত হয়।
*/

/*
TODO: Question-3: Promise কি এবং এটি কিভাবে কাজ করে ?
*/

// Answer: What is a Promise and How it Works in JavaScript

/*
প্রমিস হল একটি অবজেক্ট যা ভবিষ্যতে একটি অ্যাসিঙ্ক্রোনাস অপারেশনের ফলাফল প্রতিনিধিত্ব করে। এটি তিনটি অবস্থা থাকতে পারে: পূর্ণ (fulfilled), প্রত্যাখ্যাত (rejected), এবং মুলতুবি (pending)। যখন একটি প্রমিস পূর্ণ হয়, এটি একটি মান প্রদান করে, এবং যখন এটি প্রত্যাখ্যাত হয়, এটি একটি ত্রুটি প্রদান করে। */
// উদাহরণস্বরূপ:
let myPromise = new Promise((resolve, reject) => {
    let success = true; // Change this to false to see rejection
    if (success) {
        resolve("Promise fulfilled!");
    } else {
        reject("Promise rejected!");
    }
});

myPromise.then((message) => {
    console.log(message);
}).catch((error) => {
    console.log(error);
});

/*এই উদাহরণে, আমরা একটি প্রমিস তৈরি করেছি যা সফল হলে "Promise fulfilled!" মেসেজ প্রদান করে এবং ব্যর্থ হলে "Promise rejected!" মেসেজ প্রদান করে। আমরা .then() মেথড ব্যবহার করে সফলতার জন্য হ্যান্ডলার এবং .catch() মেথড ব্যবহার করে ত্রুটির জন্য হ্যান্ডলার সংযুক্ত করেছি।
*/

/*
TODO: Question-4: জাভাস্ক্রিপ্ট যদি সিঙ্গেল থ্রেডেড হয় , তাহলে asynchronous কাজ গুলো কিভাবে হ্যান্ডেল করে ?
*/
// Answer: How JavaScript Handles Asynchronous Tasks in a Single-Threaded Environment

/*
যদিও JavaScript একটি সিঙ্গেল-থ্রেডেড ভাষা, এটি ইভেন্ট লুপ এবং কলব্যাক কিউ এর মাধ্যমে অ্যাসিঙ্ক্রোনাস কাজগুলি পরিচালনা করতে সক্ষম হয়। যখন একটি অ্যাসিঙ্ক্রোনাস অপারেশন শুরু হয়, যেমন setTimeout বা একটি নেটওয়ার্ক অনুরোধ, এটি কল স্ট্যাক থেকে সরিয়ে ফেলা হয় এবং কলব্যাক কিউ তে রাখা হয়। ইভেন্ট লুপ তখন কল স্ট্যাক খালি হলে কলব্যাক কিউ থেকে ফাংশনগুলি কল স্ট্যাকে নিয়ে আসে এবং সেগুলি কার্যকর করে। এই প্রক্রিয়াটি JavaScript কে একই সময়ে একাধিক কাজ পরিচালনা করার অনুমতি দেয়, যদিও এটি একটি সিঙ্গেল থ্রেড ব্যবহার করে।
*/

/*
TODO: Question-5: async/await কি এবং এটি কিভাবে কাজ করে ?
*/
// Answer: What is async/await and How it Works in JavaScript

/*
async/await হল JavaScript এ অ্যাসিঙ্ক্রোনাস কোড লেখার একটি সহজ এবং পরিষ্কার উপায়। একটি ফাংশনকে async কিওয়ার্ড দিয়ে চিহ্নিত করা হয়, যা নির্দেশ করে যে ফাংশনটি একটি প্রমিস রিটার্ন করবে। await কিওয়ার্ডটি শুধুমাত্র async ফাংশনের ভিতরে ব্যবহার করা যেতে পারে এবং এটি একটি প্রমিসের সমাধান হওয়া পর্যন্ত ফাংশনটির কার্যক্রম স্থগিত করে। এটি কোডকে সিঙ্ক্রোনাসের মতো দেখতে এবং পড়তে সহজ করে তোলে, যদিও এটি আসলে অ্যাসিঙ্ক্রোনাস।
*/

// উদাহরণস্বরূপ:
async function fetchData() {
    try {
        let response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        let data = await response.json();
        console.log(data);
    }
    catch (error) {
        console.log('Error:', error);
    }
}
fetchData();

/*
এই উদাহরণে, fetchData ফাংশনটি async হিসাবে চিহ্নিত করা হয়েছে। আমরা await ব্যবহার করে fetch কল এবং response.json() কলের জন্য অপেক্ষা করছি। এটি নিশ্চিত করে যে আমরা ডেটা প্রাপ্ত হওয়ার আগে পরবর্তী লাইনটি কার্যকর করব না। যদি কোনো ত্রুটি ঘটে, এটি catch ব্লকে ধরা হবে এবং কনসোলে প্রদর্শিত হবে।
*/

/*
TODO: Question-6: SetTimeout() যদি seconds প্যারামিটার বাদ দেয়া হয় তাহলে ডিফল্ট কত মাইক্রোসেকেন্ড ধরে নেয় ?
*/
// Answer: 
// If the seconds parameter is omitted in setTimeout(), it defaults to 0 milliseconds (0 microseconds).
// This means the function will be executed as soon as possible after the current call stack is cleared.
/*

explain in Bangla:
যদি setTimeout() ফাংশনে সেকেন্ড প্যারামিটারটি বাদ দেওয়া হয়, তাহলে এটি ডিফল্টভাবে 0 মিলিসেকেন্ড (0 মাইক্রোসেকেন্ড) এ সেট করা হয়। এর মানে হল যে ফাংশনটি যত তাড়াতাড়ি সম্ভব বর্তমান কল স্ট্যাক পরিষ্কার হওয়ার পরে কার্যকর করা হবে।
*/

/*
TODO: Question-7: জাভাস্ক্রিপ্ট কিভাবে কোড রান করে ?
*/

// Answer: How JavaScript Executes Code

/*
JavaScript একটি ইন্টারপ্রেটেড ভাষা যা ব্রাউজার বা Node.js এর মতো রানটাইম পরিবেশে কোড চালায়। যখন JavaScript কোড লোড হয়, এটি প্রথমে একটি কল স্ট্যাক তৈরি করে এবং তারপর কোডটি লাইন বাই লাইন পড়ে এবং কার্যকর করে। সিঙ্ক্রোনাস কোড সরাসরি কল স্ট্যাকে যোগ করা হয় এবং অবিলম্বে কার্যকর করা হয়। অ্যাসিঙ্ক্রোনাস কোড, যেমন setTimeout বা প্রমিস, কল স্ট্যাক থেকে সরিয়ে ফেলা হয় এবং কলব্যাক কিউ তে রাখা হয়। ইভেন্ট লুপ তখন কল স্ট্যাক খালি হলে কলব্যাক কিউ থেকে ফাংশনগুলি কল স্ট্যাকে নিয়ে আসে এবং সেগুলি কার্যকর করে। এই প্রক্রিয়াটি JavaScript কে একই সময়ে একাধিক কাজ পরিচালনা করার অনুমতি দেয়, যদিও এটি একটি সিঙ্গেল থ্রেড ব্যবহার করে। */

/*
TODO: Question-8: JavaScript এ Hoisting কি এবং এটি কিভাবে কাজ করে ?
*/

// Answer: What is Hoisting and How it Works in JavaScript
/*
Hoisting হল JavaScript এর একটি বৈশিষ্ট্য যেখানে ভেরিয়েবল এবং ফাংশন ডিক্লারেশনগুলি তাদের ডিক্লারেশন থেকে আগে কল স্ট্যাকে "উঠিয়ে নেওয়া" হয়। এর মানে হল যে আপনি একটি ভেরিয়েবল বা ফাংশনকে তার ডিক্লারেশনের আগে ব্যবহার করতে পারেন। তবে, শুধুমাত্র ডিক্লারেশনগুলি হোস্ট করা হয়, ইনিশিয়ালাইজেশন নয়। */

// উদাহরণস্বরূপ:
console.log(myVar); // Output: undefined
var myVar = 10;

myFunction(); // Output: "Hello, Hoisting!"
function myFunction() {
    console.log("Hello, Hoisting!");
}
/*এই উদাহরণে, আমরা দেখতে পাচ্ছি যে myVar ভেরিয়েবলটি ডিক্লারেশনের আগে কনসোলে প্রিন্ট করা হয়েছে এবং এটি undefined আউটপুট দেয় কারণ শুধুমাত্র ডিক্লারেশনটি হোস্ট করা হয়েছে, ইনিশিয়ালাইজেশন নয়। একইভাবে, myFunction ফাংশনটি ডিক্লারেশনের আগে কল করা হয়েছে এবং এটি সঠিকভাবে কাজ করে কারণ ফাংশন ডিক্লারেশনগুলি সম্পূর্ণরূপে হোস্ট করা হয়।
*/

/*
TODO: Question-9: JavaScript এ 'this' কীওয়ার্ড কি এবং এটি কিভাবে কাজ করে ?
*/

// Answer: What is the 'this' Keyword and How it Works in JavaScript
/*
'this' কীওয়ার্ডটি JavaScript এ একটি বিশেষ ভেরিয়েবল যা বর্তমান অবজেক্টকে নির্দেশ করে। এর মানে 'this' এর মান নির্ভর করে এটি কোথায় এবং কিভাবে ব্যবহৃত হচ্ছে তার উপর। সাধারণত, 'this' একটি ফাংশনের ভিতরে ব্যবহৃত হলে, এটি সেই ফাংশনটি কল করা অবজেক্টকে নির্দেশ করে। তবে, কনটেক্সট অনুযায়ী এর মান পরিবর্তিত হতে পারে। */

// উদাহরণস্বরূপ:
const obj = {
    name: 'JavaScript', 
    getName: function() {
        console.log(this.name);
    }
};
obj.getName(); // Output: "JavaScript"
/*এই উদাহরণে, getName ফাংশনের ভিতরে 'this' কীওয়ার্ডটি obj অবজেক্টকে নির্দেশ করে, তাই এটি 'JavaScript' প্রিন্ট করে। যদি আমরা getName ফাংশনটি সরাসরি কল করি, তাহলে 'this' গ্লোবাল অবজেক্টকে নির্দেশ করবে (ব্রাউজারে window এবং Node.js এ global)।
*/

/*
TODO: Question-10: JavaScript এ Closures কি এবং এটি কিভাবে কাজ করে ?
*/
// Answer: What are Closures and How they Work in JavaScript
/*
ক্লোজার হল একটি ফাংশন যা তার বাইরের ফাংশনের স্কোপ থেকে ভেরিয়েবলগুলি অ্যাক্সেস করতে পারে। এটি তখন ঘটে যখন একটি ফাংশন অন্য একটি ফাংশনের ভিতরে ডিফাইন করা হয় এবং বাইরের ফাংশনটি সম্পন্ন হওয়ার পরেও ভিতরের ফাংশনটি সেই বাইরের ফাংশনের ভেরিয়েবলগুলি অ্যাক্সেস করতে পারে। */
// উদাহরণস্বরূপ:
function outerFunction() {
    let outerVar = 'I am from outer function';  
    function innerFunction() {
        console.log(outerVar);
    }
    return innerFunction;
}

const myClosure = outerFunction();
myClosure(); // Output: "I am from outer function"
/*এই উদাহরণে, innerFunction একটি ক্লোজার কারণ এটি outerFunction এর স্কোপ থেকে outerVar ভেরিয়েবলটি অ্যাক্সেস করতে পারে, যদিও outerFunction ইতিমধ্যেই সম্পন্ন হয়েছে। যখন আমরা myClosure কল করি, এটি outerVar এর মান প্রিন্ট করে।
*/

/*
TODO: Question-11: JavaScript এ Event Delegation কি এবং এটি কিভাবে কাজ করে ?
*/

// Answer: What is Event Delegation and How it Works in JavaScript
/*
ইভেন্ট ডেলিগেশন হল একটি টেকনিক যেখানে একটি প্যারেন্ট এলিমেন্ট ইভেন্ট হ্যান্ডলার সেট করে এবং তার চাইল্ড এলিমেন্টগুলির ইভেন্টগুলি পরিচালনা করে। এটি DOM এ ইভেন্ট বুবলিং এর উপর ভিত্তি করে কাজ করে, যেখানে ইভেন্টগুলি চাইল্ড এলিমেন্ট থেকে প্যারেন্ট এলিমেন্টের দিকে বুবল আপ হয়। ইভেন্ট ডেলিগেশন ব্যবহার করার মাধ্যমে আমরা কম মেমরি ব্যবহার করতে পারি এবং ডায়নামিকলি যোগ করা এলিমেন্টগুলির জন্যও ইভেন্ট হ্যান্ডলার সেট করতে পারি। */
// উদাহরণস্বরূপ:
document.getElementById('parent').addEventListener('click', function(event) {
    if (event.target && event.target.matches('button.child')) {
        console.log('Child button clicked:', event.target.textContent);
    }
});
/*এই উদাহরণে, আমরা একটি প্যারেন্ট এলিমেন্টে ক্লিক ইভেন্ট হ্যান্ডলার সেট করেছি। যখন কোনো চাইল্ড বাটনে ক্লিক করা হয়, ইভেন্ট হ্যান্ডলারটি চেক করে যে ক্লিক করা এলিমেন্টটি একটি বাটন কিনা এবং তারপর সেই বাটনের টেক্সট কনটেন্ট প্রিন্ট করে। এইভাবে, আমরা প্রতিটি চাইল্ড বাটনের জন্য আলাদা ইভেন্ট হ্যান্ডলার সেট না করেই ইভেন্টগুলি পরিচালনা করতে পারি।
*/

/*
TODO: Question-12: what is javaScript?
*/
// Answer: What is JavaScript?
/*
JavaScript হল একটি উচ্চ-স্তরের, ইন্টারপ্রেটেড প্রোগ্রামিং ভাষা যা ওয়েব ডেভেলপমেন্টে ব্যাপকভাবে ব্যবহৃত হয়। এটি মূলত ওয়েব পেজে ইন্টারেক্টিভ উপাদান যোগ করার জন্য ডিজাইন করা হয়েছে, তবে এখন এটি সার্ভার-সাইড ডেভেলপমেন্ট, মোবাইল অ্যাপ্লিকেশন, গেম ডেভেলপমেন্ট এবং আরও অনেক ক্ষেত্রে ব্যবহৃত হয়। JavaScript একটি মাল্টি-প্যারাডাইম ভাষা যা অবজেক্ট-ওরিয়েন্টেড, ফাংশনাল এবং ইম্পেরেটিভ প্রোগ্রামিং শৈলীতে কোড লেখার অনুমতি দেয়। এটি ব্রাউজারের ভিতরে রান করে এবং HTML এবং CSS এর সাথে মিলিত হয়ে ওয়েব পেজগুলিকে ডায়নামিক এবং ইন্টারেক্টিভ করে তোলে। */


/*
TODO: Question-13: JIT Compiled process বুঝানোর জন্য ধাপে ধাপে ফ্লো চার্ট কোড লিখো 
*/

// Answer: Step-by-Step Flow Chart Code for JIT Compilation Process
/*
JIT (Just-In-Time) কম্পাইলার হল একটি প্রযুক্তি যা রানটাইমে কোডকে মেশিন কোডে রূপান্তর করে, যা প্রোগ্রামের কার্যকারিতা উন্নত করে। নিচে JIT কম্পাইলেশন প্রক্রিয়ার ধাপে ধাপে ফ্লো চার্ট কোড দেওয়া হল:
*/
/*
1. Start;
2. Load JavaScript Code
3. Parse JavaScript Code
4. Generate Intermediate Representation (IR)
5. Is the Code Hot (Frequently Executed)?
   - Yes: Proceed to Step 6 
    - No: Execute Code using Interpreter (Go to Step 10)
6. Optimize Intermediate Representation
7. Compile Optimized IR to Machine Code
8. Store Compiled Machine Code in Cache
9. Execute Compiled Machine Code
10. End
/*এই ফ্লো চার্টটি JIT কম্পাইলার কীভাবে কাজ করে তা ধাপে ধাপে ব্যাখ্যা করে। প্রথমে, JavaScript কোড লোড এবং পার্স করা হয়, তারপর একটি ইন্টারমিডিয়েট রিপ্রেজেন্টেশন তৈরি করা হয়। যদি কোডটি হট (প্রায়ই কার্যকর) হয়, তবে এটি অপ্টিমাইজ করা হয় এবং মেশিন কোডে কম্পাইল করা হয়। এই মেশিন কোডটি ক্যাশে সংরক্ষণ করা হয় এবং পরবর্তীতে কার্যকর করা হয়। যদি কোডটি হট না হয়, তবে এটি ইন্টারপ্রেটার ব্যবহার করে কার্যকর করা হয়।
*/

/*
TODO: Question-14: জাভাস্ক্রিপ্ট মেমরি ম্যানেজমেন্ট এবং গার্বেজ কালেকশন প্রসেস কিভাবে কাজ করে ?
*/
// Answer: How JavaScript Memory Management and Garbage Collection Process Works
/*
JavaScript মেমরি ম্যানেজমেন্ট স্বয়ংক্রিয়ভাবে পরিচালিত হয়, যার মানে ডেভেলপারদের মেমরি বরাদ্দ এবং মুক্তি সম্পর্কে চিন্তা করতে হয় না। যখন একটি ভেরিয়েবল বা অবজেক্ট তৈরি করা হয়, তখন JavaScript রানটাইম মেমরি বরাদ্দ করে। যখন সেই ভেরিয়েবল বা অবজেক্ট আর ব্যবহৃত হয় না, তখন গার্বেজ কালেকশন প্রক্রিয়া মেমরিটি মুক্ত করে দেয়। */
// গার্বেজ কালেকশন সাধারণত "mark-and-sweep" অ্যালগরিদম ব্যবহার করে কাজ করে। এই প্রক্রিয়ায়, গার্বেজ কালেক্টর সক্রিয়ভাবে মেমরিতে থাকা অবজেক্টগুলিকে চিহ্নিত করে যা আর অ্যাক্সেসযোগ্য নয় এবং সেগুলিকে মেমরি থেকে সরিয়ে দেয়। এটি মেমরি লিক প্রতিরোধ করে এবং অ্যাপ্লিকেশনের পারফরম্যান্স উন্নত করে। JavaScript এর গার্বেজ কালেকশন প্রক্রিয়া স্বয়ংক্রিয় হওয়ায় ডেভেলপাররা তাদের কোডে মেমরি ব্যবস্থাপনা নিয়ে কম চিন্তা করতে পারে। 
